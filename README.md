# 462-Blog

### Introduction

  Hello! My name is Ian Dudderar and I am a senior CS major at College of Charleston. I recently took 362 with Dr. Bowring last semester (Fall 2020), and that was my only experience using GitHub. I will say that while I still feel very new to the platform and its uses and operations, I feel confident I can take what I learned in the previous course and apply it to this one so that I may continue learning.


---

### Reflections on FOSS

  The title of this reading is the first thing that jumped out at me. It is very obviously comparing two structures of very different purpose, feeling, and environment. Two important areas each with a very unique image in my head, both images contrasting each other greatly. A cathedral I often imagine to be large and structured, filled with patient and inactive individuals seated and silent. Everyone there has a shared idea or mentality. On the other hand, the image of a bazaar in my head consists of loud noise and lots of movement. I picture people rushing around to get things done, shouting at each other. Each person there for a different purpose and with a different idea, covered in sweat and dirt due to their hard work and activity levels. So what do these two buildings have to do with open source software? 
  
  The answer to that is actually pretty easy when it is explained to you, as in the paper. Until a certain time, the approach to software design could be viewed similar to that of a cathedral; quiet, structured, peaceful, problem free. Programmers believed that a central approach was needed, where software was developed in a manner that ensured it could be released in waves, with lots of time and testing inbetween. All of the dirty work behind the scenes was hidden, and only the finish product, a grand, beautiful structure, was shown to the public. Linus Torvald, however, had a different approach. He believed software development should resemble a bazarr in that it should consist of multiple ideas and thoughts all being thrown together, assuming the good ideas would prevail and the bad ones would wither away. By releasing sotware early and often, more people can provide input to what is being created and therefore more ideas can be shared. 
  
  Furthermore, the writing suggests that "given enough eyeballs, all bugs are shallow." In other words, if enough people can see a product, bugs can be found and patched quicker. While previously bugs were carefully searched for and patched before release, by releasing early and often it allows for more bugs to be found and for them to be fixed quicker.


---


### Reflections on Open Source in Today's World

  Josip Almasi's article "Why I Rewrote my Open Source Virtual Reality Server" dives into one of the major issues with modern VR development companies, as well as explains his solution. In a world where everything is always about money, he believes that issue has leaked into software design and in this particular situation the development of the VR industry. Comapnies wish to lock down developers faster and longer than their competitors so that they may win the ongoing race to distribute more product and make more money. In another unforunate series of events, we live in a world where data is a heavily mainlined product among an incredible amount of different industries, and this one is no different. Some VR headsets will track a ridiculous and unnecessary amount of your biometric data and immediately sell it off to any private organization. By creating his own open source VR server, Almasi has created a safe and private enrionment for his young children and family to all interact together and enjoy the outstanding modern technology the world has to offer, without worry that their privacy is being breached. 

  Meanwhile, Emily Shannon's [article](https://opensource.com/article/17/10/enable-update) highlights the Duke University eNable group which revolves around using open sourced software to assist in the creation of 3D-printed prosthetics for amputees. The article lists multiple modular devices which have been created and loaded with different open-sourced software to assist a wide range of people all over the world, including a young child in Milot, Haiti. To me it is so neat to see the type of open sourced programs that are available out there, whether it be to help a hand pinch or an arm move. In Chris's specific case, the young boy from Haiti, they utilized a design called the Gripper Thumb Hand. The fact that these types of software exist out in the internet for anyone to use is absolutely incredible and a wholesome and wonderful use of modern technologies. Using the software, the Duke eNable team was able to produce a 3D-printed plaster prototype and eventually come up with a final device that allows Chris to use his new arm with very few limitations. They were even able to provide him with spare parts. How neat is that!
  
  
---
  
  ### This Bugs Me
  
  On the sugarlabs github, it would appear one of the oldest bug reports comes from over 3 years ago on Feb. 1st, 2018. The documenter describes a glitch in which the copy and paste function is having an issue working properly. Apparently if one starts up the desktop and copies and paste a single block of text, it works as intented. However, if one should copy one line of text, and then copy another before pasting, the final result will not paste, and actually nothing will be pasted. If I can be frank I have absolutely no idea what would cause something like this. Perhaps when the new text is copied, the old text is deleted from the clipboard, but it is never properly replaced by the new text. My theory for why it has not been resolved is that perhaps it is not a groundbreaking issue. If copying two things to the clipboard nulls them both, they could just recopy the most recent to make it work properly again. Most users probably just assume they did not select 'copy' properly, so when they do it again it works fine.
    
   Upon scouting out some of the more recent bugs, it appears there is a commonly seen error that goes into effect when users attempt to view a specific help page. There is supposed to be an activity help page that can be accessed by pressing alt+shift+H, however this takes you to a page with a bad gateway 502 error. I was in fact able to recreate this issue, as it was super simple, and it appears the devs are already aware of the problem and mentioning different possible fixes. Doing this exercise really demonstrated to me how important it is to properly document any located bugs because reading through some of the posts was very confusing as lots of them were difficult to follow and not written with the guidelines shown.
   
   Attempting to triage the bugs in this software proved to be a challenge. Many of the bugs seem trivial to me, an outsider, and therefore I do not know how to rank them, or estimate the time or effort it might take to fix one. Many of the bugs are not well documented, and instead are users simplying saying something "is broken". It's all kind of funny to read after reading the information in the TOS exercises, as it feels like I am quickly learning the importance of the reading, due to the real-world difficulties being demonstrated by poorly documented issues.
   
---

### What's Happening?

  For my article, I chose to read "Right Code" by Gerard Holmann, in the IEE Software Magazine. I am very afraid of planes and plane crashes by nature, so this article immediately grabbed my attention. Large mechanical failues due to small software errors while increasingly rare, are always tragic and spur up major conversation. It appears no matter how much the importance of proper testing and coding is pushed, human error will always find a way to show through, and I do not envision a world where this does not occur. After two of Boeing's new 737 MAX airplanes crashed, a report was published placing the blame on multiple parties and a sequence of bad practice, not just one simple fault. After a test failure of Boeing's CST Starliner system, NASA discovered the issue was due to many software bugs, calling into question the entirety of the company's testing process. The issue is that it is very difficult to come up with a single remedy that will solve any and all problems.
  
  Something interesting that stands out to me is the article's mention that oftentimes reliability is reached through redundancy. Creating multiple methods to accomplish the same task in independent manners so that should one fail, backups are available. This seems like such an obviously inefficient way of doing things,  yet at the same time makes perfect sense to me, as in some cases you would rather be safe than sorry. It goes on to mention that by increasing assertions in code may correlate strongly with fewer faults. As I have only recently learned what assertions are in regards to coding, this was intriguing to read about.
  
  As far as testing goes, the author states that tests should stemp from the requirements that prompted the codes creation, not a predetermined structure in a control-flow graph. Tests should handle a range of cases that both have expected results as well as violate certain rules. 
   
  
---

### Stupid or Solid?

  In the world of object oriented programming, the term STUPID may refer to an acronym that has been around for a while in order to describe some inherent issues behind poorly designed code. The letters stand for Singleton, Tight Coupling, Untestabilitiy, Premature Organization, Indescriptive Naming, and Duplication. As we dive deeper into these categories, we can see the negatives of each and become aware of why they should be avoided. The singleton pattern identifies a well-known pattern design in which a class is created in order to create a single object. While it can be beneficial, overuse of this can cause many problems and may lead to tight coupling. Tight coupling should be avoided so that separate program modules do not rely on each other. If you wish to make a change in a specific module, you do not want to be required to make changes in another as well. Should this occur, it will make testing very difficult, and may be an indicator of untestability. Everyone knows the importance of thoroughly testing code to be aware of any faults or potential issues. If your program is designed in a way that makes testing difficult, you're going to have a bad time. Moving forward, premature optimzation may cause someone to spend a lot of time perfecting something that does not need to or is not ready to be perfected. Code is constantly transforming and changes are always being made, therefore it may be a large waste to spend a big effort perfecting something that will only be altered in the future. This article goes on to make an important point regarding indescriptive naming. Words are for people, not for computers. It makes no sense to abbreviate variables or classes, as instead they should be given clear names and descriptors so that other people may understand them. The final letter in STUPID stands for duplication, and touches on the notion that there is no need to repeat code if it is unnecessary. Make things easier for yourself.
  
  
  On the flip side, the mnemonic SOLID may help us remember a collection of good principles and guidelines. Beginning with the Single Responsibility Principle, we learn that every class should have only one responsbility. Do not assign multiple jobs to a single class, as there is no need to overload a class with too many different responsibilities. The Open/Closed principle refers to the notion that software should be open for extension but closed for modification. In other words, variables should be made private, and getters and setters exist only where needed. The L in SOLID indicates the Liskov Substitution Principle, which says objects need to be able to be replaced by subtypes without making the program incorrect.Furthermore the interface segregation principle states that many speficic interafaces are superior to one giant one derived for many general purposes. You do not want to be obligated to impliment methods that you wont end up using. This helps to prevent coupling which we talked about earlier. Lastly, the dependency inversion principle enforces two guidelines; abstractions should not depend on details, and vice versa. 

---

### Release Early and Often

  In an effort to ensure a progressing system between programmers and users, the phrase release early and often has been coined. What this explicitly refers to is the need for developers to not shy away from releasing a version of software to be tested or used in fear that it may not be flawless. The strength of the idea is built upon the notion that by frequently making changes for the userbase to experience, feedback can be obtained and necessary adjustments can be made. This creates an ongoing cycle of new content and testing/review. This may initially seem like a bad idea, as programmers want to ensure their content is polished and bug free before others can run it, but doing so allows for hesitation and delays. Releasing early and often allows for outside help and input to be utilized during the coding process. 
  
  Proper code commenting and documentation are also vital attributes to the open source world. Without it, others will waste a great deal of time and effort trying to understand code that could have been explained in a few sentences of documenting. In order to do this properly, it is not uncommon for certain tools to be necessary, such as an editor in which to write a way to markup and publish, and a method of collaboration between other writers. Rather than view the system as artistic writing, one instead could take a more logical and processed approach. By simply following the steps of the waterfall method a programmer can ensure the comments they are producing are satisfactory. The waterfall method is commonly used among software projects, and its steps include planning, content, writing, localisation, and review. The idea is that the first step should assist you with the second step, the second should assist with the third, and so on.



---

### Chapter 6

  This chapter really grabbed my attention in the very first paragraph. As someone who has a lot of friends already out working in the real world, whether it be in business, sales, or computing, I have frequently overheard things about databases. And each time, I have had no clue what was being discussed. The chapter mentions that students are often very familiar with programming and data structures, and not so much with database development, which is a central role in real world projects. This could not feel more accurate for me.
  
  To me the idea that data will "persist" is such an intriguing aspect. For example, as someone who pays attention to sports, I will oftentimes hear facts or stats mentioned that occurred years and years ago, way before I was even born. I have always wondered "how on earth do they still have access to that information?" In the same way, data we keep now will eventually need to be kept past the medium on which it is stored. For this reason, data in a database is said to have persistence, and needs to be treated as such.
  
  I also really enjoyed reading about queries. I took a class involving functional programming and we used queries a lot. Initially the concept of queries was a tricky one to grasp in a programming sense, which is funny because in the real world it is such an easy idea to wrap my head around. Seeing that queries are used frequently in databases and knowing that I have some experience with them already made me feel somewhat prepared and glad that I had taken the course. It also allowed me to see databases in a medium that I am already familiar with

---

### Meeting Charleston

  For my meeting Charleston event, I attented the CofC alumni symposium. The event was very interactive and helpful. It consisted of three different alumni of various ages and backgrounds, which inherently provided some diversity in both personality and advice. The layout was very simple and easy to follow; each of the three presenters took the initial time to provide a brief introduction about themselves, consisting of their educational background and their work history. Then the event shifted into a q&a session, in which each of the viewers had an opportunity to ask any or all of the presenters questions about school and the workforce. It was very basic yet helpful, as the viewers were able to come up with a large quantity of great questions.
  
  For me personally, I very much enjoyed hearing the alumni talk about their interviewing processes and provide tips in that area. As a senior who will be graduating soon, the notion of having to put myself out there to apply for jobs and impress potential employers sounds very overwhelming. They were able to make the idea sound more realistic and less built up in my head, and allowed me to see that these people were all once students just like me and in my same position. One speaker in particular spoke on his past in which he changed his major. He mentioned that he did not feel like he was in the right place, and a change was needed, even though he was dead in the middle of school. Things worked out well for him and he seemed happy. To me this was very reassuring, as it demonstrated that at any time in life, if you are unhappy, it is never too late to work to make a change that may benefit you in the future.
